package com.ironcorelabs.large;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.stream.Stream;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.AbstractMap;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

import com.ironcorelabs.tenantsecurity.kms.v1.*;
import com.ironcorelabs.tenantsecurity.kms.v1.exception.*;

public class LargeDocuments {
    public static void main(String[] args) throws Exception {
        // In order to communicate with the TSP, you need a matching API_KEY. Find the
        // right value from end of the TSP configuration file, and set the API_KEY
        // environment variable to that value.
        String API_KEY = System.getenv("API_KEY");
        if (API_KEY == null) {
            System.out.println("Must set the API_KEY environment variable.");
            System.exit(1);
        }

        // For this example, make sure you use a tenant that has security event logging
        // enabled so you can actually see the events logged to the appropriate SIEM.
        String TENANT_ID = System.getenv("TENANT_ID");
        if (TENANT_ID == null) {
            TENANT_ID = "tenant-gcp";
        }
        System.out.println("Using tenant " + TENANT_ID);

        // Initialize the client with a Tenant Security Proxy domain and API key.
        // Typically this would be done once when the application or service initializes
        TenantSecurityClient client = TenantSecurityClient.create("http://localhost:32804", API_KEY).get();

        // Create metadata used to associate this document to a tenant, name the
        // document, and identify the service or user making the call
        DocumentMetadata metadata = new DocumentMetadata(TENANT_ID, "serviceOrUserId", "PII");

        // Example 1: encrypting a large document, using the filesystem for persistence
        //
        // This whole file is an example of how you can avoid calls to the KMS/TSP when
        // you have a tightly defined "document", even if that document is actually made
        // up of many entities in a database. This shouldn't be done with disparate
        // pieces of data that will commonly be decrypted/encrypted separately from each
        // other. At that point using `[encrypt|decrypt]DocumentBatch()` is the better
        // option, allowing you to make a single call to the TSP but still have
        // different keys for each data piece.

        String filename = "large-document.json";
        String subfolder = "sub-docs";

        // create a place to put files generated by this run
        Path tmpFileDir = Files.createTempDirectory("saas-shield");
        System.out.println("Writing encrypted files and performance to: " + tmpFileDir);

        ObjectMapper objectMapper = new ObjectMapper();
        BigDoc sourceObj = objectMapper.readValue(new File("./resources/" + filename));

        // Reduce the document to a map of all the sub documents to be encrypted with
        // the same key
        Map<String, byte[]> docToEncrypt = Stream.of(sourceObj.subDocs)
                .map(subDoc -> new AbstractMap.SimpleEntry<>(subDoc.subDocId,
                        objectMapper.writeValueAsString(subDoc).getBytes()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        try {
            // Request a key from the KMS and use it to encrypt all the sub documents
            EncryptedDocument encryptedDocument = client.encrypt(docToEncrypt, metadata).get();

            // write the encrypted key to the filesystem
            String encryptedDocumentEncryptionKey = encryptedDocument.getEdek();
            Path edekPath = Paths.get(tmpFileDir.toString(), filename + ".edek");
            Files.write(edekPath, encryptedDocumentEncryptionKey.getBytes());

            // write the encrypted docs to the filesystem
            encryptedDocument.getEncryptedFields().entrySet().stream().forEach(entry -> {
                String subDocId = entry.getKey();
                Path subDocPath = Paths.get(tmpFileDir.toString(), subDocId + ".enc");
                byte[] subDocEncryptedBytes = entry.getValue();
                Files.write(subDocPath, subDocEncryptedBytes);
            });
        } catch (ExecutionException e) {
            if (e.getCause() instanceof TenantSecurityException) {
                TenantSecurityException error = (TenantSecurityException) e.getCause();
                TenantSecurityErrorCodes errorCode = error.getErrorCode();
                System.out.println("\nError Message: " + error.getMessage());
                System.out.println("\nError Code: " + errorCode.getCode());
                System.out.println("\nError Code Info: " + errorCode.getMessage() + "\n");
            }
            throw e;
        }

        System.exit(0);
    };
}
